use anyhow::{Context, Result};
use chrono::NaiveDate;
use clap::Parser;
use dialoguer::{theme::ColorfulTheme, MultiSelect};
use rspotify::{
    model::{AlbumType, IncludeExternal, Market, SearchResult, SearchType, SimplifiedAlbum},
    prelude::*,
    scopes, AuthCodeSpotify, Credentials, OAuth,
};

#[derive(Parser)]
#[command(version, about, long_about=None)]
struct Args {
    artist_name: String,

    #[arg(
        short = 'n',
        long = "name",
        help = "Name of the playlist. Defaults to: <artist_name> Discography"
    )]
    playlist_name: Option<String>,

    #[arg(
        short,
        long,
        help = "Sort the tracks in descending order by release date, instead of ascending order."
    )]
    descending: bool,
}

#[tokio::main]
async fn main() {
    let args = Args::parse();
    println!("artist: {:?}", args.artist_name);

    // check if we already have the user's credentials stored.
    let creds = Credentials::from_env()
        .context("Failed to get credentials from environment.")
        .unwrap();
    let oath = OAuth::from_env(scopes!("playlist-modify-public")).unwrap();

    let spotify = AuthCodeSpotify::new(creds, oath);

    let url = spotify.get_authorize_url(false).unwrap();

    spotify
        .prompt_for_token(&url)
        .await
        .unwrap_or_else(|err| panic!("Failed to get token: {:?}", err));

    // search for artist ID using inputted artist name

    let search_result = spotify
        .search(
            &args.artist_name,
            SearchType::Artist,
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap_or_else(|err| panic!("Failed to search for artist: {:?}", err));

    let artists = match search_result {
        SearchResult::Artists(artists_page) => artists_page.items,
        _ => panic!(
            "Expected artists in search result, instead got: {:?}",
            search_result
        ),
    };

    if artists.is_empty() {
        panic!("No artists found for search query: {}", args.artist_name);
    }

    let artist = &artists[0];
    println!("Found artist: {}", artist.name);

    // search for albums by artist

    let mut albums: Vec<SimplifiedAlbum> = vec![];

    let include_groups = [AlbumType::Album, AlbumType::Single];
    let limit = 50;
    let offset = 0;
    loop {
        let album_page = spotify
            .artist_albums_manual(
                artist.id.clone(),
                include_groups,
                None,
                Some(limit),
                Some(offset),
            )
            .await
            .unwrap();

        for item in album_page.items {
            println!("{:?}", item.name);
            albums.push(item);
        }

        if album_page.next.is_none() {
            break;
        }
    }

    // TODO: add logic to sort out singles that are already included in albums

    // sort albums by release date (ascending or descending depending on args)
    albums.sort_by(|a, b| {
        let date_a = parse_date(&a.release_date);
        let date_b = parse_date(&b.release_date);

        if args.descending {
            date_b.cmp(&date_a)
        } else {
            date_a.cmp(&date_b)
        }
    });

    for album in &albums {
        println!(
            "{:?} {:?} {:?}",
            album.release_date, album.name, album.album_type
        );
    }

    let album_choices: Vec<(String, bool)> =
        albums.iter().map(|a| (a.name.clone(), true)).collect();

    // have user select albums to include in playlist
    let selected_albums = MultiSelect::with_theme(&ColorfulTheme::default())
        .with_prompt("Select albums to include in playlist")
        .items_checked(&album_choices)
        .interact()
        .unwrap();

    println!("Selected albums:");
    for i in selected_albums {
        println!("{:?}", albums[i].name);
    }

    // create a new playlist

    // let user_id = spotify.current_user().await.unwrap().id;

    // let playlist_name = args
    //     .playlist_name
    //     .unwrap_or(format!("{} Discography", args.artist));

    // let playlist_description = format!(
    //     "The entire discrography of {}. Auto-generated by AllTracks: https://github.com/bradwj/alltracks",
    //     args.artist
    // );

    // let playlist = spotify
    //     .user_playlist_create(
    //         user_id,
    //         &playlist_name,
    //         Some(true),
    //         Some(false),
    //         Some(&playlist_description),
    //     )
    //     .await
    //     .unwrap_or_else(|err| panic!("Failed to create playlist: {:?}", err));

    println!("done");
}

fn parse_date(date_str: &Option<String>) -> Option<NaiveDate> {
    date_str
        .as_ref()
        .and_then(|s| NaiveDate::parse_from_str(s, "%Y-%m-%d").ok())
}
