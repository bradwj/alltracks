use anyhow::{Context, Result};
use clap::Parser;
use rspotify::{
    model::{AlbumType, IncludeExternal, Market, SearchResult, SearchType, SimplifiedAlbum},
    prelude::*,
    scopes, AuthCodeSpotify, Credentials, OAuth,
};

#[derive(Parser)]
#[command(version, about, long_about=None)]
struct Args {
    artist_name: String,

    #[arg(
        short = 'n',
        long = "name",
        help = "Name of the playlist. Defaults to: <artist_name> Discography"
    )]
    playlist_name: Option<String>,

    #[arg(
        short,
        long,
        help = "Sort the tracks in descending order by release date, instead of ascending order."
    )]
    descending: bool,
}

#[tokio::main]
async fn main() {
    let args = Args::parse();
    println!("artist: {:?}", args.artist_name);

    // check if we already have the user's credentials stored.
    let creds = Credentials::from_env()
        .context("Failed to get credentials from environment.")
        .unwrap();
    let oath = OAuth::from_env(scopes!("playlist-modify-public")).unwrap();

    let spotify = AuthCodeSpotify::new(creds, oath);

    let url = spotify.get_authorize_url(false).unwrap();

    spotify
        .prompt_for_token(&url)
        .await
        .unwrap_or_else(|err| panic!("Failed to get token: {:?}", err));

    // search for artist ID using inputted artist name

    let search_result = spotify
        .search(
            &args.artist_name,
            SearchType::Artist,
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap_or_else(|err| panic!("Failed to search for artist: {:?}", err));

    let artists = match search_result {
        SearchResult::Artists(artists_page) => artists_page.items,
        _ => panic!(
            "Expected artists in search result, instead got: {:?}",
            search_result
        ),
    };

    if artists.is_empty() {
        panic!("No artists found for search query: {}", args.artist_name);
    }

    let artist = &artists[0];
    println!("Found artist: {}", artist.name);

    // search for albums by artist

    let mut albums: Vec<SimplifiedAlbum> = vec![];

    let include_groups = [AlbumType::Album, AlbumType::Single];
    let limit = 50;
    let offset = 0;
    loop {
        let album_page = spotify
            .artist_albums_manual(
                artist.id.clone(),
                include_groups,
                None,
                Some(limit),
                Some(offset),
            )
            .await
            .unwrap();

        for item in album_page.items {
            println!(
                "{} {}",
                item.album_type.as_ref().unwrap_or(&"".to_string()),
                item.name
            );
            albums.push(item);
        }

        if album_page.next.is_none() {
            break;
        }
    }

    // create a new playlist

    // let user_id = spotify.current_user().await.unwrap().id;

    // let playlist_name = args
    //     .playlist_name
    //     .unwrap_or(format!("{} Discography", args.artist));

    // let playlist_description = format!(
    //     "The entire discrography of {}. Auto-generated by AllTracks: https://github.com/bradwj/alltracks",
    //     args.artist
    // );

    // let playlist = spotify
    //     .user_playlist_create(
    //         user_id,
    //         &playlist_name,
    //         Some(true),
    //         Some(false),
    //         Some(&playlist_description),
    //     )
    //     .await
    //     .unwrap_or_else(|err| panic!("Failed to create playlist: {:?}", err));

    println!("done");
}
