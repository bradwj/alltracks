use anyhow::Context;
use chrono::NaiveDate;
use clap::Parser;
use dialoguer::{theme::ColorfulTheme, MultiSelect};
use open;
use rspotify::{
    model::{AlbumType, PrivateUser, SearchResult, SearchType, SimplifiedAlbum, SimplifiedTrack},
    prelude::*,
    scopes, AuthCodeSpotify, Credentials, OAuth,
};

#[derive(Parser)]
#[command(version, about, long_about=None)]
struct Args {
    artist_name: String,

    #[arg(
        short = 'n',
        long = "name",
        help = "Name of the playlist. Defaults to: <artist_name> Discography"
    )]
    playlist_name: Option<String>,

    #[arg(
        short,
        long,
        help = "Sort the tracks in descending order by release date, instead of ascending order."
    )]
    descending: bool,
}

#[tokio::main]
async fn main() {
    let args = Args::parse();
    println!("artist: {:?}", args.artist_name);

    // check if we already have the user's credentials stored.
    let creds = Credentials::from_env()
        .context("Failed to get credentials from environment.")
        .unwrap();
    let oath = OAuth::from_env(scopes!("playlist-modify-public")).unwrap();

    let spotify = AuthCodeSpotify::new(creds, oath);

    let url = spotify.get_authorize_url(false).unwrap();

    spotify
        .prompt_for_token(&url)
        .await
        .unwrap_or_else(|err| panic!("Failed to get token: {:?}", err));

    // search for artist ID using inputted artist name

    let search_result = spotify
        .search(
            &args.artist_name,
            SearchType::Artist,
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap_or_else(|err| panic!("Failed to search for artist: {:?}", err));

    let artists = match search_result {
        SearchResult::Artists(artists_page) => artists_page.items,
        _ => panic!(
            "Expected artists in search result, instead got: {:?}",
            search_result
        ),
    };

    if artists.is_empty() {
        panic!("No artists found for search query: {}", args.artist_name);
    }

    let artist = &artists[0];
    println!("Found artist: {}", artist.name);

    // search for albums by artist

    let mut albums: Vec<SimplifiedAlbum> = vec![];

    let include_groups = [AlbumType::Album, AlbumType::Single];
    let limit = 50;
    let offset = 0;
    loop {
        let album_page = spotify
            .artist_albums_manual(
                artist.id.clone(),
                include_groups,
                None,
                Some(limit),
                Some(offset),
            )
            .await
            .unwrap();

        albums.extend(album_page.items);

        if album_page.next.is_none() {
            break;
        }
    }

    // TODO: add logic to sort out singles that are already included in albums

    // sort albums by release date (ascending or descending depending on args)
    albums.sort_by(|a, b| {
        let date_a = parse_date(&a.release_date);
        let date_b = parse_date(&b.release_date);

        if args.descending {
            date_b.cmp(&date_a)
        } else {
            date_a.cmp(&date_b)
        }
    });

    for album in &albums {
        println!(
            "{:?} {:?} {:?}",
            album.release_date, album.name, album.album_type
        );
    }

    let album_choices: Vec<(String, bool)> = albums
        .iter()
        .map(|a| {
            (
                format!(
                    "[{} {}]\t{}",
                    a.album_type.clone().unwrap_or(String::from("")),
                    a.release_date.clone().unwrap_or(String::from("")),
                    &a.name
                ),
                true,
            )
        })
        .collect();

    // have user select albums to include in playlist
    let selected_albums = MultiSelect::with_theme(&ColorfulTheme::default())
        .with_prompt("Select albums to include in playlist")
        .items_checked(&album_choices)
        .interact()
        .unwrap();

    let mut tracks: Vec<SimplifiedTrack> = vec![];
    for album_index in selected_albums {
        let album = &albums[album_index];
        println!("Getting tracks for album: {:?}", album.name);

        let album_tracks = spotify
            .album_track_manual(album.id.clone().unwrap(), None, Some(limit), Some(offset))
            .await
            .unwrap_or_else(|err| {
                panic!("Failed to get album tracks for {:?}: {:?}", album.name, err)
            });

        tracks.extend(album_tracks.items);
    }

    // create a new playlist

    let playlist_name = args
        .playlist_name
        .unwrap_or(format!("{} Discography", args.artist_name));

    let playlist_description = format!(
        "The entire discrography of {}. Auto-generated by AllTracks: https://github.com/bradwj/alltracks",
        args.artist_name
    );

    let user: PrivateUser = spotify
        .current_user()
        .await
        .unwrap_or_else(|err| panic!("Failed to get current user information: {:?}", err));

    let playlist = spotify
        .user_playlist_create(
            user.id,
            &playlist_name,
            Some(true),
            Some(false),
            Some(&playlist_description),
        )
        .await
        .unwrap_or_else(|err| panic!("Failed to create playlist: {:?}", err));

    // add tracks to playlist

    let track_ids: Vec<PlayableId> = tracks
        .iter()
        .map(|t| PlayableId::Track(t.id.clone().unwrap()))
        .collect();

    // let playlist_result = spotify
    //     .playlist_add_items(playlist.id, track_ids, Some(0))
    //     .await
    //     .unwrap_or_else(|err| panic!("Failed to add tracks to playlist: {:?}", err));
    // maximum of 100 tracks can be added at once per API request
    let mut offset = 0;
    while offset < track_ids.len() {
        let end = (offset + 100).min(track_ids.len());
        let slice = &track_ids[offset..end];
        let items = slice.iter().map(|id| id.as_ref()).collect::<Vec<_>>();

        let _playlist_result = spotify
            .playlist_add_items(playlist.id.clone(), items, Some(offset as u32))
            .await
            .unwrap_or_else(|err| panic!("Failed to add tracks to playlist: {:?}", err));

        offset += 100;
    }

    let playlist_link: String = playlist
        .external_urls
        .get("spotify")
        .cloned()
        .unwrap_or("N/A".to_string());

    println!(
        "Playlist created: {:?} (link: {})",
        playlist.name,
        playlist_link.clone()
    );

    open::that(playlist_link).unwrap_or_else(|err| {
        println!("Failed to open playlist link in browser: {:?}", err);
    });
}

fn parse_date(date_str: &Option<String>) -> Option<NaiveDate> {
    date_str
        .as_ref()
        .and_then(|s| NaiveDate::parse_from_str(s, "%Y-%m-%d").ok())
}
